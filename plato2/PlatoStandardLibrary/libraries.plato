library Interval
{
    Size(x: Interval): Numerical 
        => x.Max - x.Min;
    
    IsEmpty(x: Interval): Boolean 
        => x.Min >= x.Max;
    
    Lerp(x: Interval, amount: Number): Numerical 
        => x.Min.Lerp(x.Max, amount);
    
    InverseLerp(x: Interval, value: Numerical): Unit 
        => (value - x.Min) / x.Size;
    
    Negate(x: Interval): Interval 
        => (-x.Max, -x.Min);
    
    Reverse(x: Interval): Interval 
        => (x.Max, x.Min);
        
    Center(x: Interval): Numerical
        => x.Lerp(0.5);    
    
    Contains(x: Interval, value: Numerical): Boolean 
        => x.Min <= value && value <= x.Max;
    
    Contains(x: Interval, other: Interval): Boolean 
        => x.Min <= other.Min && x.Max >= other.Max;
    
    Overlaps(x: Interval, y: Interval): Boolean 
        => !x.Clamp(y).IsEmpty;
    
    Split(x: Interval, t: Number): Tuple2 
        => (x.Left(t), x.Right(t));
    
    Split(x: Interval): Tuple2
        => x.Split(0.5);

    Left(x: Interval, t: Number): Interval
        => (x.Min, x.Lerp(t));
    
    Right(x: Interval, t: Number): Interval
        => (x.Lerp(t), x.Max);

    MoveTo(x: Interval, v: Numerical): Interval
        => (v, v + x.Size);
    
    LeftHalf(x: Interval): Interval 
        => x.Left(0.5);
    
    RightHalf(x: Interval): Interval 
        => x.Right(0.5);
    
    HalfSize(x: Interval): Numerical 
        => x.Size.Half;
    
    Recenter(x: Interval, c: Numerical): Interval 
        => (c - x.HalfSize, c + x.HalfSize);
    
    Clamp(x: Interval, y: Interval): Interval
        => (x.Clamp(y.Min), x.Clamp(y.Max));
    
    Clamp(x: Interval, value: Interpolatable): Interpolatable 
        => value.Lerp(x.Min, x.Max, value.Unlerp(x.Min, x.Max).Clamp(0, 1));
    
    Within(x: Interval, value: Numerical): Boolean
        => value >= x.Min && value <= x.Max;
}

library Vector
{
    Aggregate(v: Vector, f: Function2): Numerical
    {
        var r = v[0];
        for (var i=1; i < v.Count; ++i)
            r = f(r, v[i]);
        return r;
    }    

    Sum(v: Vector): Numerical 
        => v.Aggregate(0, Add); 
    
    SumSquares(v: Vector): Numerical
        => v.Square.Sum; 
    
    MagnitudeSquared(v: Vector): Numerical
        => v.SumSquares;
    
    Magnitude(v: Vector): Numerical
        => v.MagnitudeSquared.SquareRoot;
    
    Dot(v1: Vector, v2: Vector): Numerical
        => (v1 * v2).Sum;

    Normal(v: Vector): Vector
        => v / v.Magnitude;

    Average(v: Vector): Numerical
        => v.Sum / v.Count;
}

library Numerical
{
    SquareRoot(x: Number): Number 
        => x.Pow(0.5);

    Square(x: Numerical): Numerical 
        => x * x;

    Clamp(x: Number): Number 
        => Clamp(x, (0, 1));

    PlusOne(x: Numerical): Numerical 
        => x + x.One;

    MinusOne(x: Numerical): Numerical
        => x - x.One;
    
    FromOne(x: Numerical): Numerical 
        => x.One - x;

    IsPositive(x: Numerical): Boolean
        => x.GtEqZ;

    GtZ(x : Numerical): Boolean
        => x > x.Zero;

    LtZ(x : Numerical): Boolean
        => x < x.Zero;

    GtEqZ(x : Numerical): Boolean
        => x >= x.Zero;

    LtEqZ(x : Numerical): Boolean
        => x <= x.Zero;

    IsNegative(x: Numerical): Boolean
        => x < x.Zero;

    Sign(x: Numerical): Numerical 
        => x.LtZ ? -x.One : x.GtZ ? x.One : x.Zero;
    
    Abs(x: Numerical): Numerical 
        => x.LtZ ? -x: x;
    
    Half(x: Numerical): Numerical 
        => x / 2;
    
    Third(x: Numerical): Numerical 
        => x / 3;
    
    Quarter(x: Numerical): Numerical 
        => x / 4;

    Fifth(x: Numerical): Numerical 
        => x / 5;
    
    Sixth(x: Numerical): Numerical 
        => x / 6;
    
    Seventh(x: Numerical): Numerical 
        => x / 7;
    
    Eighth(x: Numerical): Numerical 
        => x / 8;
    
    Ninth(x: Numerical): Numerical 
        => x / 9;
    
    Tenth(x: Numerical): Numerical 
        => x / 10;
    
    Sixteenth(x: Numerical): Numerical 
        => x / 16;
    
    Hundredth(x: Numerical): Numerical 
        => x / 100;
    
    Thousandth(x: Numerical): Numerical 
        => x / 1000;
    
    Millionth(x: Numerical): Numerical 
        => x / 1000 / 1000;
    
    Billionth(x: Numerical): Numerical 
        => x / 1000 / 1000 / 1000;
    
    Hundred(x: Numerical): Numerical 
        => x * 100;
    
    Thousand(x: Numerical): Numerical
        => x * 1000;
    
    Million(x: Numerical): Numerical
        => x * 1000 * 1000;
    
    Billion(x: Numerical): Numerical 
        => x * 1000 * 1000 * 1000;
    
    Twice(x: Numerical): Numerical 
        => x * 2;
    
    Thrice(x: Numerical): Numerical 
        => x * 3;
    
    SmoothStep(x: Numerical): Numerical 
        => x.Square * (3 - x.Twice);
    
    Pow2(x: Numerical): Numerical 
        => x * x;
    
    Pow3(x: Numerical): Numerical 
        => x.Pow2 * x;

    Pow4(x: Numerical): Numerical 
        => x.Pow3 * x;

    Pow5(x: Numerical): Numerical 
        => x.Pow4 * x;

    Pi(): Number 
        => 3.1415926535897;
    
    AlmostZero(x: Number): Boolean
        => x.Abs < 0.00000001; 

    Lerp(a: Numerical, b: Numerical, t: Number): Number
        => (a.One - t) * a + t * b;
        
    Between(self: Comparable, min: Comparable, max: Comparable): Boolean
        => self >= min && self <= max;
}

library Angles 
{
    Radians(x : Number): Angle
        => x;

    Degrees(x: Number): Angle
        => x * Pi / 180; 
        
    Turns(x: Number): Angle 
        => x * 2 * Pi;    
}

library Comparable
{
    Equals(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) == 0;
    
    LessThan(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) < 0;
    
    LessThanOrEquals(a: Comparable, b: Comparable): Boolean
        => a.Compare(b) <= 0;
    
    GreaterThan(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) > 0;
    
    GreaterThanOrEquals(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) >= 0;
    
    Between(v: Comparable, a: Comparable, b: Comparable): Value 
        => v >= a && v <= b;
    
    Min(a: Comparable, b: Comparable): Comparable 
        => a <= b ? a : b;
    
    Max(a: Comparable, b: Comparable): Comparable 
        => a >= b ? a : b;
}